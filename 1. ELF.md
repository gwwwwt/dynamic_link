# ELF



## 1. ELF格式文件类型

|            ELF文件类型             | 说明                                                         | 实例                             |
| :--------------------------------: | ------------------------------------------------------------ | :------------------------------- |
|  可重定位文件（Relocatable File）  | 这类文件包含了代码与数据，可以被用来链接<br />成可执行文件或共享目标文件，静态链接库也<br />可以归为这一类 | Linux的.o<br />Windows的.obj     |
|   可执行文件（Executable File）    | 这类文件包含了可直接执行的程序，它的代表就是<br />ELF可执行文件，它们一般都没有扩展名 | /bin/bash文件<br />Windows的.exe |
| 共享目标文件（Shared Object File） |                                                              | Linux的.so，<br />Windows的.dll  |
|   核心转储文件（Core Dump File）   |                                                              | Linux下的core dump               |



## 2. 目标文件（.o）结构

![](./assets/程序与目标文件.png)

![](./assets/ELF结构.png)



+   **`ELF文件头`**：描述整个文件的基本属性，例如ELF文件版本、目标机器型号、程序入口地址等
+   **`各个ELF Section`**
+   **`段表（Section header table）`**：描述了ELF文件包含的所有段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其它属性。
+   **`字符串表`**
+   **`符号表`**



### 2.1 文件头

>   包含**`ELF魔数`**、**`文件机器字节长度`**、**`数据存储方式`**、**`版本`**、**`运行平台`**、**`ABI版本`**、**`ELF重定位类型`**、**`硬件平台`**、**`硬件平台版本`**、**`入口地址`**、**`程序头入口和长度`**、**`段表位置和长度`**、**`段数量`**等

![](./assets/ELF文件头.png)



对应结构定义：*`/usr/include/elf.h`*中的**`struct Elf32_Ehdr`**

![](./assets/Elf32_Ehdr.png)



### 2.2 段表

`段表`描述了ELF的各个段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限以及段的其它属性。段表在ELF文件中的位置由ELF文件头的**`e_shoff`**成员决定。

`objdump -h`命令只是将ELF文件中关键的段显示出来，而省略了其它辅助性的段，比如：符号表、字符串表、段名字符串表、重定位表等。可以使用`readelf`工具来查看ELF文件的段，它显示的结果才是真正的段表结构：

![](./assets/段表.png)



#### 2.2.1 Elf32_Shdr 结构体

![](./assets/Elf32_Shdr.png)



### 2.3 重定位表

一个重定位表同时也是ELF的一个段，那么这个段的类型（sh_type）就是"SHT_REL"类型，它的"sh_link"表示符号表的下标，它的"sh_info"表示它作用于哪个段。比如".rel.text"作用于".text"段，而".text"段的下标为1，那么".rel.text"的"sh_info"为"1"。



重定位表是静态链接的核心，所以到静态链接部分再整理重定位表。



### 2.4 字符串表

示例：

![](./assets/ELF字符串表.png)

则偏移与它们对应的字符串如下：

![](./assets/ELF字符串表解析.png)



常见的ELF文件中的字符串表存放在两个段中`.strtab`和`.shstrtab`，分别代表"字符串表（String Table）"、"段表字符串表（Section Header String Table）"。





### 2.5 符号 -- 链接的接口

在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。比如目标文件B要用到了目标文件A中的函数"foo"，我们就称目标文件A**`定义（Define）`**了函数"foo"，称目标文件B**`引用（Reference）`**了目标文件A中的函数"foo"。这两个概念同样适用于变量，每个函数或变量都有自己独特的名字，才能避免链接过程中不同变量和函数之间的混淆。在链接中，我们将函数和变量统称为**`符号（Symbol）`**，函数名或变量名就是**`符号名（Symbol Name）`**。

我们可以将**`符号`**看作是链接中的粘合剂，整个链接过程正是基于符号才能够正确完成。每一个目标都会有一个对应的**`符号表（Symbol Table）`**，这个表里记录了目标文件中所用到的所有符号。每个定义的符号有一个对应的值，叫做**`符号值（Symbol Value）`**，对于变量和函数来说，**`符号值就是它们的地址`**。除了函数和变量之外，还存在其它几种不常用到的符号。具体的符号分类如下：

+   定义在本目标文件中的全局符号，可以被其它目标文件引用。比如SimpleSection.o里面的"func1"、"main"等
+   在本目标文件中引用的全局符号，但没有定义在本目标文件中，这一般叫做“外部符号（External Symbol）”，也就是前面说的**`符号引用`**，例如SimpleSection.o里面的"printf"
+   段名，由编译器产生
+   局部符号，只在编译单元内部可见
+   行号信息，可选



![](./assets/nm信息.png)



