# Linux共享库的组织

Linux中存在大量的共享对象，为了更好地将这些共享对象组织起来，方便以后的维护以及升级，Linux对共享对象的目录组织和使用方法有一定规则。

## 1. 共享库版本

>   共享库基本就等同于共享对象

### 1.1 共享库兼容性

导致C语言共享库ABI改变的行为主要有以下4个:

+   导出函数的行为发生改变
+   导出函数被删除
+   导出的数据结构发生变化
+   导出函数的接口发生变化



对于C++来说就多了，这里略过



### 1.2 共享库版本命名

>   Linux有一套规则来命名系统中的每个共享库，它规定共享库的文件名规则必须如下:
>
>   +   `libname.so.x.y.z`
>       +   `x`：主版本号，表示库的重大升级，不同主版本号的库之间是不兼容的
>       +   `y`：次版本号，表示库的增量升级，即增加一些新的接口符号，且保持原来的符号不变。在主版本号相同的情况下，高的次版本号的库向后兼容低的次版本号的库。
>       +   `z`：发布版本号，表示库的一些错误修正、性能的改进，并不添加任何新的接口，也不对接口进行更改。



### 1.3 SO-NAME

`程序需要记录什么`

假设程序中有一个它所依赖的共享库列表，其中每一项对应于它所依赖的一个共享库。可以肯定，程序中必须包含被依赖的共享库的名字和主版本号。因为不同主版本号之间的共享库是不兼容的，所以程序中保存一个诸如`libfoo.so.2`的记录，以防止动态链接器在运行时意外地将程序与`libfoo.so.1`或`libfoo.so.3`链接到一起。通过这个可以发现，如果在系统中运行旧的应用程序，就需要在系统中保留旧应用程序所需要的旧的主版本号的共享库。



`SO-NAME`

对于新的系统，普通采用一种叫做**`SO-NAME`**的命名机制来记录共享库的依赖关系。每个共享库都有一个对应的`SO-NAME`，这个`SO-NAME`即共享库的文件名去掉次版本号和发布版本号，保留主版本号。

>   比如一个共享库叫做`libfoo.so.2.6.1`，那么它的`SO-NAME`就是`libfo.so.2`。
>
>   很明显，`SO-NAME`规定了共享库的接口，`SO-NAME`相同的两个共享库，次版本号大的兼容次版本号小的。在Linux系统中，系统会为每个共享库在它的所在目录创建一个跟`SO-NAME`相同的并且指向它的`软链接`。
>
>   >   比如系统中有一个共享库`/lib/libfoo.so.2.6.1`，那么Linux中的共享库管理程序就会为它产生一个`/lib/libfoo.so.2`指向它。
>
>   >   以`SO-NAME`的名字建立软链接的好处：实际上这个软链接会指向目录中主版本号相同、次版本号和发布版本号最新的共享库。这样保证了所有以`SO-NAME`为名的软链接都指向系统中最新版的共享库。
>
>   >   建立以`SO-NAME`为名字的软链接的目的是，使所有依赖某个共享库的模块，在编译、链接和运行时，都会用共享库的`SO-NAME`，而不使用详细的版本号。这样在共享库进行升级时，如果只进行增量升级，即保持主版本号不变，只改变次版本号或发布版本号，那么可以直接将新版的共享库替换掉旧版，并且修改`SO-NAME`软链接的指向，即可实现升级，而不需要保留旧版的库，从而节省存储空间。
>
>   >   Linux中提供了一个工具叫`ldconfig`，它会遍历所有的默认共享库目录，更新所有的软链接，使它指向最新的库。如果有新的共享库，那么`ldconfig`会为它创建相应的软链接。



`链接名`

在编译器使用共享库的时候，比如需要链接一个`libXXX.so.2.6.1`的共享库，只需要在编译器命令行中指定`-lXXX`即可，可省略掉其它部分。编译器会根据当前环境，在系统中的相关路径（通常由`-L`参数指定）查找最新的`XXX`库。这个`XXX`就被称为共享库的`链接名`。



## 2. 符号版本

在一些早期系统中，构建的应用程序中包含所依赖的共享库主版本号、次版本号等详细信息，这样就出现了一个问题，当动态链接器根据版本号去系统中查找对应的共享库时，可能会找不到与应用程序中版本号完全一致的共享库，但找到版本号不同的共享库，这样出现两个情况:

+   如果找到的共享库次版本号高于所依赖的共享库次版本号，动态链接器可以直接使用这个库，因为其向后兼容
+   如果找到的共享库次版本号低于所依赖的共享库次版本号时，就可能导致程序无法运行，这个问题就叫做`次版本号交会问题`，并且这个问题并不能被`SO-NAME`解决。



基本解决思路就是共享库次版本号升级时，新共享库相比旧版本中新引入的符号的符号名添加相应的版本后缀，例如`libfoo.so.2.6.1`比`libfoo.so.2.5.1`新引入了一个全局变量叫做`VAR`，那么在编译共享库后，`VAR`在`libfoo.so.2.6.1`中的符号名会变为`VAR_2.6`。

这样的话如果动态链接库在查找应用程序依赖的共享库时只查找到了次版本号较低的库，可以通过应用程序中引用的符号名来确定这个较低版本的库是否可用，如果可用的话，则使用这个较低版本的库即可。



## 3. 共享库系统路径

`FHS(File Hierarchy Standard)`标准规定，一个系统中主要有两个存放共享库的位置:

+   `/lib`主要存放系统最关键和基础的共享库，这些库主要是那些`/bin`和`/sbin`下的程序所需要用到的库，还有系统启动时需要的库
+   `/usr/lib`主要保存非系统运行时所需要的关键库，主要是开发时用到的库
+   `/usr/local/lib`用来放置一些跟操作系统本身并不十分相关的库，主要是一些第三方的应用程序库



## 4. 共享库查找过程

程序所依赖的模块路径保存在`.dynamic`段里面，由`DT_NEED`类型的项表示，这些共享对象全部由动态链接器负责装载和初始化。

动态链接器对于模块的查找有一定的规则: 如果`DT_NEED`里面保存的是绝对路径，则直接按照这个路径查找；如果保存的是相对路径，动态链接器会在`/lib`、`/usr/lib`、`/etc/ld.so.conf`配置文件指定的目录中查找共享库。



## 5. 环境变量

+   `LD_LIBRARY_PATH`：临时改变某个应用程序的共享库查找路径，而不会影响到其它程序。如果设置了此环境变量，动态链接器会先到些环境变量指定的目录中查找共享库，所以可以通过此方式测试新的共享库或使用非标准共享库
+   `LD_PRELOAD`：指定预先装载的共享库甚至是目标文件
+   `LD_DEBUG`：打开动态链接器的调试功能



## 6. 共享库的创建与安装

### 6.1 创建

```bash
$ gcc -shared -fPIC -W1, -soname,my_soname -o library_name source_files library_files
```



### 6.2 清除符号信息

正常编译出来的共享库或可执行文件里面带有符号信息或调试信息，这些信息对于发布版本来说用处不大，可以使用`strip`来清除掉

```bash
$ strip libfoo.so
```



### 6.3 共享库的安装

+   最简单的办法就是将共享库复制到某个标准的共享库目录，如/lib、/usr/lib等，然后运行`ldconfig`即可

+   上述方法需要root权限，如果没有，则无法添加至标准库目录。此时需要建立相应的SO-NAME软链接，并告诉编译器和程序如何查找该共享库等。

    +   建立SO-NAME也是使用`ldconfig`，只是需要指定共享库位置

        ```bash
        $ ldconfig -n shared_library_directory
        ```

    +   在编译程序时，也需要指定共享库的位置，GCC提供了两个参数`-l`和`-L`，分别用于指定共享库路径和共享加搜索目录



### 6.4 共享库构造和析构函数

GCC提供了一种共享库的构造函数，只要在函数声明时加上*`__attribute__((constructor))`*的属性，即指定该函数为共享库构造函数，拥有这种属性的函数会在共享库加载时被执行，即在程序的`main`函数之前执行。如果使用`dlopen()`打开共享库，共享库构造函数会在`dlopen()`返回之前被执行。

与构造函数对应的是析构函数，函数声明加上*`__attribute__((destructor))`*属性，函数会在`main()`函数执行完毕后执行（或者是程序调用exit()时执行）。如果共享库是在运行时被加载的，使用`dlclose()`卸载共享库时，析构函数会在`dlclose()`返回前执行。



如果有多个构造函数或析构函数，可以在声明是变成`__attribute__((constructor(N)))`，这样`N`值越小的函数越先执行构造函数，越后执行析构函数。



### 6.5 共享库脚本

类似LD的链接脚本，语法和命令相同，作用也相似，即将一个或多个输入文件以一定的格式经过变换以后形成一个输出文件，这种脚本也叫做`动态链接脚本`。
