# 动态链接

## 1. 为什么要动态链接

>   静态链接缺点：浪费内存和磁盘空间、模块更新困难等问题。

不对那些组成程序的目标文件进行链接，等到程序运行时才进行链接。也就是说，把链接这个过程推迟到了运行时再进行，这就是**`动态链接`**的基本思想。

<img src="./assets/静态链接时文件在内存中的副本.png" style="zoom: 35%;" /><img src="./assets/动态链接时文件在内存中的副本.png" style="zoom:33%;" />

 

### 1.1 动态链接的基本实现

`动态链接`的基本思想是把程序按照模块拆分成各个相对独立的部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有的程序模块都链接成一个单独的可执行文件。

`动态链接`涉及运行时的链接及多个文件的装载，必需要有操作系统的支持。在Linux系统中，ELF动态链接文件被称为**`动态共享对象(DSO, Dynamic Shared Object)`*，简称`共享对象`，一般都是以`.so`为扩展名的一些文件。

在Linux中，常用的C语言库的运行库glibc，它的动态链接形式的版本保存在**`/lib`**目录下，文件名叫做**`libc.so`**。当程序被装载时，系统的**`动态链接器`**会将程序所需要的所有动态链接库（最基本的就是libc.so）装载到进程的地址空间，并且将程序中所有未决议的符号绑定到相应的动态链接库中，并进行重定位工作。

程序的动态链接工作是程序在装载时由`动态链接器`完成的，必定会带来一些性能损耗，当然可以通过优化方法来提高其效率，例如**`延迟绑定`**等方法。



## 2. 简单的动态链接的例子

```c
/* Program1.c */
#include "Lib.h"
int main() {
    foobar(1);
    return 0;
}

/* Program2.c */
#include "Lib.h"
int main() {
    foobar(2);
    return 0;
}

/* Lib.c */
#include <stdio.h>
void foobar(int i) {
    printf("Printing from Lib.so %d\n", i);
}

/* Lib.h */
#ifndef LIB_H
#define LIB_H
void foobar(int i);
#endif
```

+   将Lib.c编译成一个共享对象文件

    ```shell
    gcc -fPIC -shared -o Lib.so Lib.c
    ```

    +   `-shared`表示产生共享对象
    +   `-fPIC`

+   分别编译链接Program1.c和Program2.c

    ```shell
    gcc -o Program1 Program1.c ./Lib.so
    gcc -o Program2 Program2.c ./Lib.so
    ```

    +   从`Program1`的角度看，整个编译和链接过程如下:

        <img src="./assets/动态链接过程.png" style="zoom:50%;" />

    +   当模块Program1.c被编译成Program1.o时，编译器还不知道`foobar()`函数的地址。当链接器将Program1.o链接成可执行文件时，如果`foobar()`是一个定义在某个动态共享对象中的函数，那么**`链接器就会将这个符号的引用标记为一个动态链接符号，不对它进行地址重定位，把这个过程留到装载时再进行`**。



### 2.1 动态链接程序运行时地址空间分布

为了查看`Program1`程序运行时的进程空间分布，修改`Lib.c`中的`foobar()`函数如下:

```c
#include <stdio.h>
int foobar(int i) {
    printf("Printing from Lib.so %d\n", i);
    sleep(-1);
}
```

编译后可以通过如下命令查看进程的虚拟地址空间分布:

<img src="./assets/动态链接进程虚拟地址空间.png" style="zoom:50%;" />



## 3. 地址无关代码

